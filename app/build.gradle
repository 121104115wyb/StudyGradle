apply plugin: 'com.android.application'

android {
    //编译版本
    compileSdkVersion 28
    defaultConfig {
        /**
         * 你的应用id默认和包名一致，但是和包名又没有关系，修改应用id后，尽管包名一致，但是google也会认为你的应用
         * 属于两个完全不同的应用，所以在你想用相同代码打包成不同的应用时候，可以通过修改applicationId来达到你的目的
         * 例如：把下面的 applicationId "com.zxl.studygradle" 修改成为 applicationId "com.zxl.studygradle.test"
         * 然后进行debug运行后，会在手机上出现两个不同的app，打包也是如此，（同样也可以使用，相同的签名文件）
         */
        applicationId "com.zxl.studygradle"
        /**
         * 支持的最小的sdk版本
         */
        minSdkVersion 16
        //向上兼容的目标版本
        targetSdkVersion 28
        //版本编码
        versionCode 1
        //版本编号
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
    /**
     * 多渠道打包
     */

    //如果你使用productFlavors 则必须添加同一产品风格的标签
    flavorDimensions "version"
    //产品风格
    productFlavors {
        xiaomi {
            // Assigns this product flavor to the "version" flavor dimension.
            // This property is optional if you are using only one dimension.
            //定义你的标签
            dimension "version"
            //当正式打包完成之后会在你的默认的的applicationId 后面加上.xiaomi 例如 com.zxl.studygradle.xiaomi
            applicationIdSuffix ".xiaomi"
            //当正式打包完成之后，会在你的版本名称之后加上 -xiaomi
            versionNameSuffix "-xiaomi"
        }
        baidu {
            dimension "version"
            applicationIdSuffix ".baidu"
            versionNameSuffix "-baidu"
        }
    }

    //自定义apk名称含版本号信息
    android.applicationVariants.all { variant ->

        // 更新至Android Studio 3.3 gradle 4.10.1
        variant.outputs.all {
            //例如输出的apk名称为 "studyGradle-1.0-baidu-2019-03-27.apk"
            outputFileName = "studyGradle-${variant.versionName}-${releaseTime()}.apk"
            //outputFileName = "alipay-packet_${variant.versionCode}-${variant.versionName}-${releaseTime()}.apk"
        }

    }

    //签名脚本配置
    signingConfigs {
//        create("release") {
//            //正确填写你的jks文件目录地址
//            storeFile file("../config/build/studygradle.jks")
//            //签名
//            storePassword "121104115"
//            //别名标签
//            keyAlias "gradle"
//            //秘钥
//            keyPassword "121104115"
//            storeType "jks"
//        }
        //配置你的签名和密钥到本地的gradle.properties,提交代码时不提交这个文件，用来保护你的密钥安全
        //但是，当多人同时维护这个项目时，一定要记得分享
        create("release") {
            //正确填写你的jks文件目录地址
            storeFile file(KEY_PATH)
            //签名
            storePassword KEY_PASS
            //别名标签
            keyAlias ALIAS_NAME
            //秘钥
            keyPassword ALIAS_PASS
            storeType STORETYPE
        }
    }

    //编译类型
    buildTypes {
        //正式版本
        release {
            //优化png图片
            crunchPngs false
            //开启资源压缩（先去除无用资源，然后进行资源压缩，条件是混淆必须首先开启，不开启则没用）
            shrinkResources false
            //开启混淆
            minifyEnabled false
            // 不显示Log
            buildConfigField "boolean", "LOG_DEBUG", "false"
            //Zipalign优化
            zipAlignEnabled false
            //配置混淆文件
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }

        //测试版本
        debug {
            //不优化png图片(优化图片会减慢构建时间)
            crunchPngs false
            //不开启资源压缩（先去除无用资源，然后进行资源压缩，条件是混淆必须首先开启，不开启则没用）(开启资源压缩会减慢构建时间)
            shrinkResources false
            //不开启混淆(开启混淆会减慢构建时间)
            minifyEnabled true
            // 显示Log(测试版本要显示日志)
            buildConfigField "boolean", "LOG_DEBUG", "true"
            //Zipalign优化(不开启，开启减慢构建时间)
            zipAlignEnabled false
            //开启插件压缩器，该属性需要和minifyEnabled true 进行同时使用，这样，在debug模式下，虽然开启了代码混淆，但是并不会进行
            //真正的代码混淆，而是只会移除无用的代码
            useProguard false
            //配置混淆文件
            //proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            //signingConfig signingConfigs.release
        }
    }


    //添加aar包需要引入以下代码
    repositories {
        flatDir {
            dirs 'libs'
        }
    }

}
//获取编译时间
static def releaseTime() {
    return new Date().format("yyyy-MM-dd", TimeZone.getTimeZone("UTC"))
}

/**
 *  指定依赖项时，不应使用动态版本号,可能会导致意外版本更新和难以解析版本差异。
 */
dependencies {
    //添加本地的模块依赖项，使用下面这种写法，当你在as中创建module时，并制定该moudle依赖于当前的主项目，gradle会自动生成依赖
    //implementation project(':mylibrary')
    //例如新建一个librarytest的moudle并在项目的moudleSetting 中添加该moudle，这样就会自动生成下面的语句
    implementation project(':librarytest')
    //本地二进制文件依赖项,你可以把jar和aar包放入到libs中
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation 'com.android.support:appcompat-v7:28.0.0'
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
    //远程引用gson
    implementation 'com.google.code.gson:gson:2.8.5'
    //引用本地的第三方jar包---如果项目过大，可以把第三方的jar应用到library中，然后再把这个library依赖于项目即可
    implementation files('libs/tomcat7-websocket.jar')
    //引用aar包方式
    implementation(name: 'library-debug', ext: 'aar')
    /**
     * android 版本升级太快，原来的的build引入方式与现在有了很大区别，以下分享出关键字的替换 并且google在2017谷歌大会正式宣布kt作为android的默认语言
     * google想搞事
     */
    /**
     * （As3.3.2和gradle-4.10.1）
     *  最新             旧
     * implementation	compile
     * api	            compile
     * compileOnly	    provided
     * annotationProcessor	compile
     * runtimeOnly	     apk
     */
    implementation 'com.android.support:support-v4:28.0.0'





}
